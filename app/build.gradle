import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

apply plugin: 'com.android.application'
apply plugin: 'AndResGuard'
//apply plugin: 'com.dx168.fastdex'

//引用完全自定义插件，名称就是插件模块META-INF/gradle-plugins/ 目录下 properties文件的名字
//apply plugin: 'com.example.plugin'
//apply plugin: 'com.example.asmplugin'

apply from: 'CommonUtil.gradle'

apply plugin: MyPlugin

apply plugin: 'ReplaceAssetsPlugin'

ReplaceAssetsExt {

    enable = true
}
//编译时间
def static buildTime() {
    return new Date().format("yyyy-MM-dd HH:mm:ss")
}

//编译机器
def static hostName() {
    return System.getProperty("user.name") + "@" + InetAddress.localHost.hostName
}
//最新的commit版本
def revision() {
    def code = new ByteArrayOutputStream();
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = code;
    }
    return code.toString()
}

static def getDate() {
    def date = new Date()
    def formattedDate = date.format('yyyy-MM-dd-HH:mm:ss')
    return "local_time" + formattedDate
}

andResGuard {
    mappingFile = file("./resource_mapping.txt")
    //mappingFile = null
    use7zip = true
    useSign = true
    // It will keep the origin path of your resources when it's true
    keepRoot = false
    // If set, name column in arsc those need to proguard will be kept to this value
    fixedResName = "arg"
    // It will merge the duplicated resources, but don't rely on this feature too much.
    // it's always better to remove duplicated resource from repo
    mergeDuplicatedRes = true
    whiteList = [
            // your icon
            "R.mipmap.ic_launcher",
            //"R.drawable.icon",
            // for fabric
            "R.string.com.crashlytics.*",
            "R.string.not_res_proguard",
    ]
    compressFilePattern = [
            "*.png",
            "*.jpg",
            "*.jpeg",
            "*.gif",
    ]
    sevenzip {
        artifact = 'com.tencent.mm:SevenZip:1.2.21'
        //path = "/usr/local/bin/7za"
    }

    /**
     * Optional: if finalApkBackupPath is null, AndResGuard will overwrite final apk
     * to the path which assemble[Task] write to
     **/
    // finalApkBackupPath = "${project.rootDir}/final.apk"

    /**
     * Optional: Specifies the name of the message digest algorithm to user when digesting the entries of JAR file
     * Only works in V1signing, default value is "SHA-1"
     **/
    // digestalg = "SHA-256"
}




println("buildTime = " + buildTime())
android {

    compileSdkVersion rootProject.ext.compileSdkVersion

    defaultConfig {
        applicationId "com.hm.gradledemo"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName
        resValue "string", "build_time", buildTime()
        resValue "string", "build_host", hostName()
        resValue "string", "build_revision", revision()

        Map<String, ?> params = rootProject.properties

//        params.eachWithIndex { Map.Entry<String, ?> entry, int i ->
//            println("key = " + entry.key + ", value = " + entry.value)
//        }
    }

    signingConfigs {
        release {
            //读取gradle.properties的属性
            storeFile file(STORE_FILE)
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }
        debug {
            storeFile file(STORE_FILE)
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }


    }

    /**
     * 构建类型
     */
    buildTypes {
        release {
            // Enables code shrinking for the release build type.
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.debug
        }

        forTest {
            initWith debug

            ndk {
                abiFilters "armeaib"
            }

        }
    }


    flavorDimensions "tier"
    /**
     * productFlavors代码块用来配置多个产品变种。这允许你使用不同的变种配置来覆盖defaultConfig代码块中的配置，从而你创建不同版本的App。
     *
     * 产品变种 + 构建类型 构建出来的就是构建变体
     */
//    productFlavors {
//        huawei {
//            dimension "tier"
//            applicationId "com.hm.huaweigradledemo"
//        }
//        mi {
//            dimension "tier"
//            applicationId "com.hm.migradledemo"
//        }
//        productFlavors.all {
//                //您可以在构建变体配置中为清单文件中的某些属性指定值，替换AndroidManifest.xml中的CHANNEL_NAME
//            flavor -> flavor.manifestPlaceholders = [CHANNEL_NAME: name]
//        }
//    }

    //重命名apk
    android.applicationVariants.all { variant ->
        println("variant.name = " + variant.name)
        variant.outputs.all {
            //时间戳
            def timeNow
            def branchName
            int lastSplit = BRANCH.lastIndexOf("/")
            if (lastSplit != -1) {
                branchName = BRANCH.substring(lastSplit + 1)
            } else {
                branchName = BRANCH
            }
            //是否为Jenkins打包
            println("打包分支 = " + branchName + " , isJenkins = " + IS_JENKINS + " , APP_VERSION = " + APP_VERSION)
            if ("true" == IS_JENKINS) {
                //Jenkins打包的时间
                timeNow = BUILD_TIME
            } else {
                //本机打包的时间
                timeNow = getDate()
            }
            outputFileName = "${variant.name}-branch_${branchName}-${APP_VERSION}-${timeNow}.apk"
        }
    }

    println("configurations类型：" + configurations.getClass())
    /**
     * 使用方式查看这几个类
     * org.gradle.api.internal.artifacts.configurations.DefaultConfigurationContainer
     * org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal
     * org.gradle.api.artifacts.ResolutionStrategy
     * 参考文档：https://www.jianshu.com/p/322472456915
     */
//    configurations.all {
//        resolutionStrategy.dependencySubstitution {
//            // Substitute project and module dependencies
//            substitute module('org.gradle:api') with project(':api')
//            substitute project(':util') with module('org.gradle:util:3.0')
//
//            // Substitute one module dependency for another
//            substitute module('org.gradle:api:2.0') with module('org.gradle:api:2.1')
//
//            resolutionStrategy.force 'asm:asm-all:3.3.1', 'commons-io:commons-io:1.4'
//        }
//    }

}


/**
 * 解压7z文件
 * @param srcDirPath
 * @param outZipPath
 * @param sevenZipPath
 * @throws IOException* @throws InterruptedException
 */
//def static extract7z(String srcFilePath, String outZipPath, String sevenZipPath)
//        throws IOException, InterruptedException {
//    ProcessBuilder pb = new ProcessBuilder([sevenZipPath, "x", srcFilePath, "-o" + outZipPath])
//    Process process = pb.start()
//
//    InputStreamReader ir = new InputStreamReader(process.getInputStream());
//    LineNumberReader input = new LineNumberReader(ir)
//    String line;
//    while ((line = input.readLine()) != null) {
//        println("extract7z：" + input.getLineNumber() + ":" + line);
//    }
//    process.waitFor()
//    process.destroy()
//}

/**
 * 这个task用来替换assets目录下的darkmode.7z
 */
//def copyProcessedResourcesTask = task("copyProcessedResources")
//
//copyProcessedResourcesTask.actions.add(new Action<Task>() {
//
//    @Override
//    void execute(org.gradle.api.Task task) {
//        //在配置阶段不会执行，只有在执行阶段才执行
//        println("copyProcessedResourcesTask 添加action，在配置阶段会执行吗？不会。")
//        generateDarkMode()
//    }
//})
//copyProcessedResourcesTask.actions.forEach {
//    println("copyProcessedResourcesTask 的 action : ${it.toString()}")
//}

//def generateDarkMode() {
//
//    def resCompiledDirPath = "$project.buildDir/intermediates/processed_res/debug/out"
//    def resCompiledFilePath = "$resCompiledDirPath/resources-debug.ap_"
//    File resFile = new File(resCompiledFilePath)
//    if (!resFile.exists()) {
//        println("copyProcessedResources path:$resCompiledFilePath not exist")
//        return
//    } else {
//        println("copyProcessedResources path:$resCompiledFilePath")
//    }
//
//    //存放编译后的资源
//    File destFile = new File("${project.rootDir}/app/src/main/assets/compliedRes")
//    if (!destFile.exists()) {
//        destFile.mkdirs()
//    }
//    println("copyProcessedResources ${destFile.absolutePath}")
//
//    ant.unzip(src: resCompiledFilePath, dest: destFile)
//
//    def oldDarkModeFile = "${project.rootDir}/app/src/main/assets/darkmode.7z"
//    //在assets目录下新建 newSkin 文件夹
//    String newSkinDir = "${project.rootDir}/app/src/main/assets/newSkin"
//
//    File file = new File(newSkinDir)
//    file.deleteDir()
//    file.mkdirs()
//
//    println("copyProcessedResources oldDarkModeFile = " + oldDarkModeFile)
//    println("copyProcessedResources newSkinDir = " + newSkinDir)
//
//    ProcessBuilder pb = new ProcessBuilder(["which", "7z"])
//    String sevenZipPath = ""
//    try {
//        Process process = pb.start();
//        InputStreamReader ir = new InputStreamReader(process.getInputStream());
//        LineNumberReader input = new LineNumberReader(ir)
//        String tmp
//        while ((tmp = input.readLine()) != null) {
//            if (tmp.endsWith(File.separator + "7z")) {
//                sevenZipPath = tmp
//                println("do7zipCompressApk 7zip path:" + sevenZipPath)
//                break
//            }
//        }
//        process.waitFor();
//        process.destroy();
//    } catch (Exception e) {
//        println("do7zipCompressApk not found 7zip path: " + e.getMessage())
//        return
//    }
//
//    try {
//        //把老的皮肤包解压到 newSkinDir 目录下
//        extract7z(oldDarkModeFile, file.getAbsolutePath(), sevenZipPath)
//    } catch (Exception ep) {
//        println("extract7z error: " + ep.getMessage())
//    }
//
//    // 1. 把compliedRes/res/color-night-v8下面的文件都拷贝到 newSkin/color 目录下，直接替换
//
//    File colorNightV8Dir = new File(destFile.getAbsolutePath() + File.separator + "res/color")
//    //File colorNightV8Dir = new File(destFile.getAbsolutePath()+File.separator+"res/color-night-v8")
//
//    if (colorNightV8Dir.exists() && colorNightV8Dir.isDirectory()) {
//        println("----开始拷贝颜色-----")
//        File[] colorFiles = colorNightV8Dir.listFiles()
//        for (File colorFile : colorFiles) {
//            String fileName = colorFile.getName()
//            File destColorFile = new File("${newSkinDir}/color", fileName)
//            println("copy color file " + colorFile.getAbsolutePath() + "\n to " + destColorFile.getAbsolutePath())
//            Files.copy(Paths.get(colorFile.getAbsolutePath()), Paths.get(destColorFile.getAbsolutePath()), StandardCopyOption.REPLACE_EXISTING)
//        }
//        println("----拷贝颜色结束-----")
//    }
//
//    // 2. 把 newSkin 打包成 darkmodeNew.7z
//
//    String darkModeNew7zPath = "${project.rootDir}/app/src/main/assets/darkModeNew.7z"
//    package7z(newSkinDir, darkModeNew7zPath, sevenZipPath)
//
//    // 3. 把 darkmode.7z 删除
//
//    // 4. 把 darkmodeNew.7z 重命名为 darkmode.7z
//
//}

/**
 * 将文件压缩成7z文件
 * @param srcDirPath
 * @param outZipPath
 * @param sevenZipPath
 * @throws IOException* @throws InterruptedException
 */
//def static package7z(String srcFilePath, String outZipPath, String sevenZipPath)
//        throws IOException, InterruptedException {
//    //将 srcFilePath 目录下的所有文件（不包括 srcFilePath 目录） 压缩到 outZipPath。
//    ProcessBuilder pb = new ProcessBuilder([sevenZipPath, "a", "-t7z", outZipPath, srcFilePath + File.separator + "*", "-mx5"])
//    Process process = pb.start()
//
//    InputStreamReader ir = new InputStreamReader(process.getInputStream());
//    LineNumberReader input = new LineNumberReader(ir)
//    String line;
//    while ((line = input.readLine()) != null) {
//        println("package7z：" + input.getLineNumber() + ":" + line);
//    }
//    process.waitFor()
//    process.destroy()
//}


//gradle.getTaskGraph().whenReady {
//    println "whenReady Task依赖关系构建完成，size=${it.allTasks.size()}"
//    it.allTasks.forEach { task ->
//        println "whenReady taskName: ${task.name} , taskPath: ${task.path}"
//    }
//}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "com.android.support:appcompat-v7:$rootProject.ext.supportVersion"
    debugImplementation 'com.facebook.stetho:stetho:1.5.0'
    debugImplementation project(path: ':library')
}

class MyPlugin implements org.gradle.api.Plugin<org.gradle.api.Project> {
    private org.gradle.api.Project mProject

    @Override
    void apply(org.gradle.api.Project project) {
        mProject = project
        //注册监听，以统计任务的耗时
        project.gradle.addListener(new BuildTimeListener(project))
//        project.afterEvaluate {
//            Set<Task> tasks = project.getTasksByName("mergeDebugAssets", true)
//            if (tasks.isEmpty()) {
//                println("apply processDebugResources 获取 mergeDebugAssets 没有该任务")
//            } else {
//                tasks.forEach {
//                    println("apply processDebugResources 获取 mergeDebugAssets 任务名称 ${it.name} ,${it.path} ")
//                }
//            }
//
//        }
    }

}

class BuildTimeListener implements org.gradle.api.execution.TaskExecutionListener, org.gradle.BuildListener {

    org.gradle.api.Project project

    BuildTimeListener(org.gradle.api.Project project) {
        this.project = project
    }

//用来记录 task 的执行时长信息
    Map<String, TaskTimeInfo> taskTimeMap = new HashMap<>()

    @Override
    void buildStarted(org.gradle.api.invocation.Gradle gradle) {

    }

    @Override
    void settingsEvaluated(org.gradle.api.initialization.Settings settings) {

    }

    @Override
    void projectsLoaded(org.gradle.api.invocation.Gradle gradle) {

    }

    @Override
    void projectsEvaluated(org.gradle.api.invocation.Gradle gradle) {

//        Set<org.gradle.api.Task> processDebugResourcesTask = project.getTasksByName("processDebugResources", false)
//
//        Set<org.gradle.api.Task> copyProcessedResourcesTask = project.getTasksByName("copyProcessedResources", false)
//        if (copyProcessedResourcesTask.isEmpty()) {
//            println("projectsEvaluated copyProcessedResourcesTask 没有该任务")
//        } else {
//            if (!processDebugResourcesTask.isEmpty()) {
//                processDebugResourcesTask.forEach {
//                    println("projectsEvaluated processDebugResourcesTask 任务名称：${it.name} , 路径：${it.path} ")
//                }
//            }
//            copyProcessedResourcesTask.forEach {
//                it.dependsOn(processDebugResourcesTask)
//                println("projectsEvaluated copyProcessedResourcesTask 任务名称：${it.name} , 路径：${it.path} ")
//            }
//        }
//
//        Set<org.gradle.api.Task> tasks = project.getTasksByName("mergeDebugAssets", false)
//        if (tasks.isEmpty()) {
//            println("projectsEvaluated  获取 mergeDebugAssets 没有该任务")
//        } else {
//            tasks.forEach {
//                if (it.path == ":app:mergeDebugAssets") {
//                    it.dependsOn(processDebugResourcesTask, copyProcessedResourcesTask)
//                    println("projectsEvaluated 获取 mergeDebugAssets 任务名称：${it.name} , 路径：${it.path} ")
//                }
//            }
//        }
    }

    @Override
    void buildFinished(org.gradle.BuildResult buildResult) {
//        println "-----------------打印所有的任务耗时开始----------------------"
//        println "---------------------------------------"
//        println "build finished, now println all task execution time:"
//        taskTimeMap.each { k, v -> println "${k}:[${v.total}ms]" }
//        println "---------------------------------------"
//        println "---------------------------------------"
//        println "-----------------打印所有的任务耗时结束----------------------"

    }

    @Override
    void beforeExecute(org.gradle.api.Task task) {
        //task开始执行之前搜集task的信息
        TaskTimeInfo timeInfo = new TaskTimeInfo()
        timeInfo.start = System.currentTimeMillis()
        timeInfo.path = task.getPath()
        taskTimeMap.put(task.getPath(), timeInfo)
        def name = task.getName()
//        println("beforeExecute task.getName() = " + name)
//        println("beforeExecute task.getPath() = " + task.getPath())
//        println("beforeExecute task.getTemporaryDir() = " + task.getTemporaryDir())
//        def fileCollection = task.getInputs().getFiles()
//        if (fileCollection.isEmpty()) {
//            println("beforeExecute input file 没有输入文件")
//        } else {
//            fileCollection.forEach { it ->
//                //println("beforeExecute input file " + it.getAbsolutePath())
//                printlnDir("beforeExecute", name, it)
//            }
//        }
        //println("beforeExecute task.getPath() = " + fileCollection)
    }

    private void printlnDir(String tag, String taskName, File file) {
        if (file != null && file.isDirectory()) {
            //printlnDir(tag,taskName,file)
            File[] files = file.listFiles()
            for (File childFile : files) {
                printlnDir(tag, taskName, childFile)
            }
        } else {
            println(tag + ", " + taskName + ", " + file.getAbsolutePath())
        }
    }

    @Override
    void afterExecute(org.gradle.api.Task task, org.gradle.api.tasks.TaskState taskState) {
        //task执行完之后，记录结束时的时间
        TaskTimeInfo timeInfo = taskTimeMap.get(task.getPath())
        timeInfo.end = System.currentTimeMillis()
        //计算该 task 的执行时长
        timeInfo.total = timeInfo.end - timeInfo.start
        def fileCollection = task.getOutputs().getFiles()
        def name = task.getName()
//        if (fileCollection.isEmpty()) {
//            println("afterExecute input file 没有输出文件")
//        } else {
//            fileCollection.forEach { it ->
//                printlnDir("afterExecute", name, it)
//            }
//        }


        //if (task.name == "processDebugResources" && task.path == ":app:processDebugResources") {
        //在 mergeDebugAssets 任务之前替换assets目录下的 darkmode.7z


        //}

//        if (name == "mergeDebugResources") {
//            println("afterExecute task.getPath() = " + task.getPath())
//            def fileCollection = task.getOutputs().getFiles()
//            if (fileCollection.isEmpty()) {
//                println("mergeDebugResources afterExecute input file 没有输出文件")
//            } else {
//                fileCollection.forEach {
//                    println("mergeDebugResources afterExecute input file " + it.getAbsolutePath())
//                }
//            }
//        }
    }

    class TaskTimeInfo {
        //task执行总时长
        long total
        String path
        long start
        long end
    }
}
